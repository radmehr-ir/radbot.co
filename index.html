<!DOCTYPE html>
<html lang="fa" manifest="app.manifest">
<head>
  <meta charset="UTF-8">
  <title>RadBot ü§ñ</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#121212">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <link rel="icon" href="/1.png" type="image/png">
  <link rel="apple-touch-icon" href="/1.png">
  <link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.0.2/marked.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.18.0/dist/tf.min.js" defer></script>
  <script src="https://cdn.jsdelivr.net/npm/@xenova/transformers@2.5.0/dist/transformers.min.js" defer></script>
  <style>
    :root {
      --bg-color: #121212;
      --text-color: #eee;
      --accent-color: #00ffff;
      --bot-color: #a5d6a7;
      --user-color: #4fc3f7;
      --input-bg: #222;
      --input-border: #555;
      --sidebar-bg: #1f1f1f;
      --chat-bg: linear-gradient(135deg, #121212, #1a1a1a);
      --bubble-bg-user: #007acc;
      --bubble-bg-bot: #2d7a3e;
    }

    .light-theme {
      --bg-color: #f2f2f2;
      --text-color: #222;
      --accent-color: #007acc;
      --bot-color: #2d7a3e;
      --user-color: #005f99;
      --input-bg: #fff;
      --input-border: #ccc;
      --sidebar-bg: #e0e0e0;
      --chat-bg: linear-gradient(135deg, #f2f2f2, #e6e6e6);
      --bubble-bg-user: #005f99;
      --bubble-bg-bot: #2d7a3e;
    }

    .custom-theme { /* ÿ®ÿ±ÿß€å ÿ™ŸÖ‚ÄåŸáÿß€å ÿ≥ŸÅÿßÿ±ÿ¥€å */ }

    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: 'Vazirmatn', sans-serif;
      font-size: 18px;
      direction: rtl;
      background: var(--bg-color);
      color: var(--text-color);
      overflow: hidden;
    }

    #canvasBg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      opacity: 0.3;
    }

    #mainContainer {
      display: flex;
      flex-direction: row;
      height: 100vh;
      width: 100vw;
      transition: all 0.3s ease;
      overflow: hidden;
    }

    @media screen and (max-width: 768px) {
      #mainContainer {
        flex-direction: column;
      }
      #historySidebar {
        width: 100%;
        min-width: unset;
        max-width: unset;
        height: 35vh;
        border-left: none;
        border-bottom: 1px solid #333;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: contain;
      }
      #chatSection {
        flex: 1;
        margin: 5px 0;
        height: calc(65vh - 60px);
      }
      #chat {
        max-height: calc(65vh - 120px);
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: contain;
      }
      #suggestions {
        order: 2;
        margin-top: 10px;
      }
      #inputBox {
        order: 3;
      }
    }

    @media screen and (min-width: 769px) {
      #mainContainer {
        flex-direction: row;
      }
      #historySidebar {
        width: 300px;
        min-width: 200px;
        max-width: 400px;
        border-left: 1px solid #333;
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: contain;
        resize: horizontal;
      }
      #chatSection {
        margin: 5px;
      }
      #chat {
        max-height: calc(100vh - 150px);
        overflow-y: auto;
        -webkit-overflow-scrolling: touch;
        overscroll-behavior: contain;
      }
    }

    #chatSection {
      flex-grow: 1;
      display: flex;
      flex-direction: column;
      background: var(--chat-bg);
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
      transition: margin 0.3s ease;
    }

    .fullscreen #chatSection {
      margin: 0;
      border-radius: 0;
    }

    header, footer {
      background: var(--sidebar-bg);
      padding: 15px;
      text-align: center;
      font-size: 22px;
      color: var(--accent-color);
      transition: background 0.3s ease;
    }

    header { border-bottom: 1px solid var(--input-border); }
    footer { font-size: 16px; border-top: 1px solid var(--input-border); }

    .msg {
      margin: 15px 10px;
      padding: 12px 18px;
      border-radius: 15px;
      max-width: 70%;
      position: relative;
      animation: waveIn 0.5s ease-in;
      white-space: pre-wrap;
      background: var(--bubble-bg-user);
      color: #fff;
      transition: transform 0.2s ease;
    }

    .msg:hover {
      transform: scale(1.02);
    }

    .user { margin-left: auto; text-align: right; }
    .bot { background: var(--bubble-bg-bot); margin-right: auto; }

    .msg:hover .msg-actions {
      display: flex;
    }

    .msg-actions {
      display: none;
      position: absolute;
      top: -20px;
      left: 10px;
      gap: 5px;
    }

    .msg-actions button {
      background: #444;
      color: #fff;
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 3px;
    }

    .msg-actions button:hover {
      background: #555;
    }

    .timestamp {
      font-size: 12px;
      color: #ccc;
      margin-right: 10px;
      display: block;
    }

    .markdown-body { font-size: 16px; }
    .markdown-body a { color: var(--accent-color); text-decoration: underline; }
    .markdown-body ul, .markdown-body ol { padding-right: 20px; }
    .markdown-body code { background: #333; padding: 2px 4px; border-radius: 4px; }
    .markdown-body pre { background: var(--input-bg); padding: 10px; border-radius: 6px; }

    #inputBox {
      display: flex;
      padding: 10px;
      background: var(--sidebar-bg);
      gap: 8px;
      border-top: 1px solid var(--input-border);
    }

    #input {
      flex: 1;
      background: var(--input-bg);
      border: 1px solid var(--input-border);
      color: var(--text-color);
      padding: 12px;
      border-radius: 6px;
      font-family: 'Vazirmatn', sans-serif;
      font-size: 16px;
      resize: none;
      transition: border-color 0.3s ease, background-color 0.3s ease;
    }

    #input:focus {
      border-color: var(--accent-color);
      outline: none;
      animation: pulseInput 2s infinite;
    }

    @keyframes pulseInput {
      0%, 100% { background-color: var(--input-bg); border-color: var(--input-border); }
      50% { background-color: #2a2a2a; border-color: var(--accent-color); }
    }

    button {
      background: linear-gradient(135deg, #333, #444);
      color: var(--accent-color);
      border: none;
      padding: 10px 14px;
      cursor: pointer;
      border-radius: 6px;
      transition: transform 0.2s ease, background 0.3s ease;
    }

    button:hover:not(:disabled) {
      transform: scale(1.05);
      background: linear-gradient(135deg, #444, #555);
    }

    button:disabled { opacity: 0.5; cursor: not-allowed; }

    #loading, #typingIndicator {
      text-align: center;
      font-size: 14px;
      color: var(--accent-color);
      margin: 10px;
    }

    #loading { display: none; }

    .typing { display: inline-block; animation: blink 1s steps(1) infinite; }

    @keyframes blink { 0%, 50%, 100% { opacity: 1; } 25%, 75% { opacity: 0; } }
    @keyframes waveIn { from { opacity: 0; transform: translateY(20px) rotateX(-10deg); } to { opacity: 1; transform: translateY(0) rotateX(0); } }

    pre.code-block {
      background: var(--input-bg);
      color: #0f0;
      padding: 15px;
      border-radius: 8px;
      position: relative;
      overflow-x: auto;
      margin: 10px 0;
      font-size: 14px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
    }

    .code-block-buttons {
      position: absolute;
      top: 8px;
      left: 8px;
      display: flex;
      gap: 5px;
    }

    .copy-btn, .preview-btn {
      background: #444;
      color: #fff;
      font-size: 12px;
      border: none;
      padding: 4px 8px;
      cursor: pointer;
      border-radius: 3px;
      transition: background 0.3s ease;
    }

    .copy-btn:hover, .preview-btn:hover { background: #555; }

    #previewModal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--sidebar-bg);
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      z-index: 1000;
      width: 80%;
      max-width: 800px;
      height: 80%;
      max-height: 600px;
      color: var(--text-color);
    }

    #previewModal h3 {
      margin-top: 0;
      color: var(--accent-color);
    }

    #previewIframe {
      width: 100%;
      height: calc(100% - 60px);
      border: none;
      border-radius: 6px;
      background: #fff;
    }

    #previewModal button {
      width: 100%;
      margin-top: 10px;
    }

    #historySidebar {
      background: var(--sidebar-bg);
      color: var(--text-color);
      padding: 20px;
      overflow-y: auto;
      transition: width 0.3s ease;
    }

    #historySidebar h3 {
      margin-top: 0;
      border-bottom: 1px solid #444;
      padding-bottom: 10px;
      text-align: center;
      color: var(--accent-color);
    }

    #historySearch {
      width: 100%;
      padding: 8px;
      margin-bottom: 10px;
      border-radius: 6px;
      border: 1px solid var(--input-border);
      background: var(--input-bg);
      color: var(--text-color);
      font-family: 'Vazirmatn', sans-serif;
    }

    .history-msg {
      border-bottom: 1px dashed #555;
      padding: 10px;
      cursor: pointer;
      font-size: 16px;
      transition: background 0.3s ease;
    }

    .history-msg:hover { background: #333; }
    .history-msg.active { background: #444; }

    .conversation-controls {
      display: flex;
      gap: 10px;
      margin-bottom: 15px;
    }

    #themeToggle, #settingsBtn, #fullscreenBtn {
      background: linear-gradient(135deg, #333, #444);
      color: var(--accent-color);
      padding: 6px 10px;
      border-radius: 6px;
      cursor: pointer;
      transition: transform 0.2s ease;
      position: fixed;
      top: 10px;
    }

    #themeToggle { left: 10px; }
    #settingsBtn { left: 50px; }
    #fullscreenBtn { left: 90px; }

    #themeToggle:hover, #settingsBtn:hover, #fullscreenBtn:hover {
      transform: scale(1.05);
    }

    #settingsModal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--sidebar-bg);
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      z-index: 1000;
      width: 350px;
      color: var(--text-color);
    }

    #settingsModal h3 {
      margin-top: 0;
      color: var(--accent-color);
    }

    #settingsModal select, #settingsModal input {
      width: 100%;
      padding: 8px;
      margin-bottom: 10px;
      border-radius: 6px;
      border: 1px solid var(--input-border);
      background: var(--input-bg);
      color: var(--text-color);
    }

    #settingsModal button {
      width: 100%;
      margin-top: 10px;
    }

    #editModal {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: var(--sidebar-bg);
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      z-index: 1000;
      width: 350px;
      color: var(--text-color);
    }

    #editModal textarea {
      width: 100%;
      height: 100px;
      padding: 8px;
      margin-bottom: 10px;
      border-radius: 6px;
      border: 1px solid var(--input-border);
      background: var(--input-bg);
      color: var(--text-color);
      font-family: 'Vazirmatn', sans-serif;
    }

    #overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 999;
    }

    #suggestions {
      display: flex;
      gap: 8px;
      padding: 10px;
      background: var(--sidebar-bg);
      overflow-x: auto;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
    }

    .suggestion {
      background: #333;
      color: var(--text-color);
      padding: 8px 12px;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.3s ease;
    }

    .suggestion:hover { background: #444; }

    .error-message {
      background: #d32f2f;
      color: #fff;
      padding: 10px;
      border-radius: 6px;
      margin: 10px;
      text-align: center;
    }
  </style>
</head>
<body>
  <canvas id="canvasBg"></canvas>
  <div id="overlay"></div>
  <div id="settingsModal">
    <h3>ÿ™ŸÜÿ∏€åŸÖÿßÿ™</h3>
    <label for="themeSelect">ÿßŸÜÿ™ÿÆÿßÿ® ÿ™ŸÖ:</label>
    <select id="themeSelect">
      <option value="dark">ÿ™€åÿ±Ÿá</option>
      <option value="light">ÿ±Ÿàÿ¥ŸÜ</option>
      <option value="custom">ÿ≥ŸÅÿßÿ±ÿ¥€å</option>
    </select>
    <label for="customAccent">ÿ±ŸÜ⁄Ø ÿß⁄©ÿ≥ŸÜÿ™:</label>
    <input type="color" id="customAccent" value="#00ffff">
    <label for="customBg">ÿ±ŸÜ⁄Ø Ÿæÿ≥‚Äåÿ≤ŸÖ€åŸÜŸá:</label>
    <input type="color" id="customBg" value="#121212">
    <label for="languageSelect">ÿ≤ÿ®ÿßŸÜ:</label>
    <select id="languageSelect">
      <option value="fa">ŸÅÿßÿ±ÿ≥€å</option>
      <option value="en">English</option>
    </select>
    <label for="cloudSync">ŸáŸÖ⁄ØÿßŸÖ‚Äåÿ≥ÿßÿ≤€å ÿßÿ®ÿ±€å:</label>
    <input type="checkbox" id="cloudSync">
    <label for="speechEnabled">ŸÅÿπÿßŸÑ‚Äåÿ≥ÿßÿ≤€å ⁄ØŸÅÿ™ÿßÿ±:</label>
    <input type="checkbox" id="speechEnabled">
    <button onclick="saveSettings()">ÿ∞ÿÆ€åÿ±Ÿá</button>
    <button onclick="closeSettings()">ÿ®ÿ≥ÿ™ŸÜ</button>
  </div>

  <div id="editModal">
    <h3>Ÿà€åÿ±ÿß€åÿ¥ Ÿæ€åÿßŸÖ</h3>
    <textarea id="editInput"></textarea>
    <button onclick="saveEditedMessage()">ÿ∞ÿÆ€åÿ±Ÿá</button>
    <button onclick="closeEditModal()">ÿ®ÿ≥ÿ™ŸÜ</button>
  </div>

  <div id="previewModal">
    <h3>Ÿæ€åÿ¥‚ÄåŸÜŸÖÿß€åÿ¥ ⁄©ÿØ HTML</h3>
    <iframe id="previewIframe" sandbox="allow-same-origin"></iframe>
    <button onclick="closePreviewModal()">ÿ®ÿ≥ÿ™ŸÜ</button>
  </div>

  <div id="mainContainer">
    <div id="historySidebar">
      <h3>üóÇ ÿ™ÿßÿ±€åÿÆ⁄ÜŸá</h3>
      <div class="conversation-controls">
        <button onclick="newConversation()"><i class="fas fa-plus"></i> ŸÖ⁄©ÿßŸÑŸÖŸá ÿ¨ÿØ€åÿØ</button>
        <button onclick="clearHistory()"><i class="fas fa-trash"></i> Ÿæÿß⁄© ⁄©ÿ±ÿØŸÜ</button>
        <button onclick="shareConversation()"><i class="fas fa-share"></i> ÿßÿ¥ÿ™ÿ±ÿß⁄©</button>
      </div>
      <input type="text" id="historySearch" placeholder="ÿ¨ÿ≥ÿ™ÿ¨Ÿà ÿØÿ± ÿ™ÿßÿ±€åÿÆ⁄ÜŸá...">
      <div id="historyContent"></div>
    </div>

    <div id="chatSection">
      <button id="themeToggle"><i class="fas fa-moon"></i></button>
      <button id="settingsBtn"><i class="fas fa-cog"></i></button>
      <button id="fullscreenBtn"><i class="fas fa-expand"></i></button>
      <header>ü§ñ RadBot</header>
      <div id="chat"></div>
      <div id="typingIndicator" style="display: none;">RadBot ÿØÿ± ÿ≠ÿßŸÑ ÿ™ÿß€åŸæ ÿßÿ≥ÿ™<span class="typing">...</span></div>
      <div id="loading">ÿØÿ± ÿ≠ÿßŸÑ Ÿæÿ±ÿØÿßÿ≤ÿ¥<span class="typing">...</span></div>
      <div id="suggestions"></div>
      <div id="inputBox">
        <textarea id="input" rows="1" placeholder="Ÿæ€åÿßŸÖ ÿÆŸàÿØ ÿ±ÿß ÿ®ŸÜŸà€åÿ≥€åÿØ..." disabled></textarea>
        <button id="sendBtn" onclick="sendMessage()" disabled><i class="fas fa-paper-plane"></i></button>
        <button id="stopBtn" onclick="stopTyping()" style="display: none;"><i class="fas fa-stop"></i></button>
      </div>
      <footer>ÿ±ÿßÿØŸÖŸáÿ± ‚ù§Ô∏è</footer>
    </div>
  </div>

  <script>
    const API_URL = "https://api.gapgpt.app/v1/chat/completions";
    const API_KEY = "sk-2AzUYsRCUcRaNNeeAcBn3rXFuAB8u1LFNBahImJnBh0EjA6W";
    const CLOUD_API = "https://api.example.com/radbot/sync";
    const ENCRYPTION_KEY = "RadBotSecretKey";
    let conversations = [{ id: Date.now(), messages: [] }];
    let currentConversationId = conversations[0].id;
    let responseCache = new Map();
    let offlineModel = null;
    let editingMessageIndex = null;
    let isTyping = false;
    let speechEnabled = localStorage.getItem("radbot-speech") === 'true';
    const isMobile = /Mobi|Android/i.test(navigator.userAgent);

    const translations = {
      fa: {
        welcome: "ÿ≥ŸÑÿßŸÖ! ŸÖŸÜ RadBot Ÿáÿ≥ÿ™ŸÖ. ŸÖ€å‚Äåÿ™ŸàÿßŸÜ€åÿØ Ÿæ€åÿßŸÖ ÿ®ŸÜŸà€åÿ≥€åÿØ €åÿß Ÿæÿßÿ≥ÿÆ‚ÄåŸáÿß ÿ±ÿß ÿ®ÿ¥ŸÜŸà€åÿØ.",
        placeholder: "Ÿæ€åÿßŸÖ ÿÆŸàÿØ ÿ±ÿß ÿ®ŸÜŸà€åÿ≥€åÿØ...",
        history: "ÿ™ÿßÿ±€åÿÆ⁄ÜŸá",
        newConversation: "ŸÖ⁄©ÿßŸÑŸÖŸá ÿ¨ÿØ€åÿØ",
        clearHistory: "Ÿæÿß⁄© ⁄©ÿ±ÿØŸÜ",
        share: "ÿßÿ¥ÿ™ÿ±ÿß⁄©",
        searchPlaceholder: "ÿ¨ÿ≥ÿ™ÿ¨Ÿà ÿØÿ± ÿ™ÿßÿ±€åÿÆ⁄ÜŸá...",
        typing: "RadBot ÿØÿ± ÿ≠ÿßŸÑ ÿ™ÿß€åŸæ ÿßÿ≥ÿ™...",
        processing: "ÿØÿ± ÿ≠ÿßŸÑ Ÿæÿ±ÿØÿßÿ≤ÿ¥...",
        settings: "ÿ™ŸÜÿ∏€åŸÖÿßÿ™",
        theme: "ÿßŸÜÿ™ÿÆÿßÿ® ÿ™ŸÖ:",
        customAccent: "ÿ±ŸÜ⁄Ø ÿß⁄©ÿ≥ŸÜÿ™:",
        customBg: "ÿ±ŸÜ⁄Ø Ÿæÿ≥‚Äåÿ≤ŸÖ€åŸÜŸá:",
        language: "ÿ≤ÿ®ÿßŸÜ:",
        cloudSync: "ŸáŸÖ⁄ØÿßŸÖ‚Äåÿ≥ÿßÿ≤€å ÿßÿ®ÿ±€å:",
        speechEnabled: "ŸÅÿπÿßŸÑ‚Äåÿ≥ÿßÿ≤€å ⁄ØŸÅÿ™ÿßÿ±:",
        save: "ÿ∞ÿÆ€åÿ±Ÿá",
        close: "ÿ®ÿ≥ÿ™ŸÜ",
        error: "ÿÆÿ∑ÿß€å€å ÿ±ÿÆ ÿØÿßÿØ. ŸÑÿ∑ŸÅÿßŸã ÿØŸàÿ®ÿßÿ±Ÿá ÿßŸÖÿ™ÿ≠ÿßŸÜ ⁄©ŸÜ€åÿØ €åÿß ÿßÿ™ÿµÿßŸÑ ÿß€åŸÜÿ™ÿ±ŸÜÿ™ ÿÆŸàÿØ ÿ±ÿß ÿ®ÿ±ÿ±ÿ≥€å ⁄©ŸÜ€åÿØ.",
        offline: "ÿ≠ÿßŸÑÿ™ ÿ¢ŸÅŸÑÿß€åŸÜ: ŸÑÿ∑ŸÅÿßŸã ÿ®Ÿá ÿß€åŸÜÿ™ÿ±ŸÜÿ™ ŸÖÿ™ÿµŸÑ ÿ¥Ÿà€åÿØ.",
        edit: "Ÿà€åÿ±ÿß€åÿ¥",
        copy: "⁄©Ÿæ€å",
        preview: "Ÿæ€åÿ¥‚ÄåŸÜŸÖÿß€åÿ¥",
        speak: "ŸæÿÆÿ¥ ÿµŸàÿ™€å"
      },
      en: {
        welcome: "Hello! I'm RadBot. You can type a message or listen to responses.",
        placeholder: "Type your message...",
        history: "History",
        newConversation: "New Conversation",
        clearHistory: "Clear History",
        share: "Share",
        searchPlaceholder: "Search in history...",
        typing: "RadBot is typing...",
        processing: "Processing...",
        settings: "Settings",
        theme: "Select Theme:",
        customAccent: "Custom Accent Color:",
        customBg: "Custom Background Color:",
        language: "Language:",
        cloudSync: "Cloud Sync:",
        speechEnabled: "Enable Speech:",
        save: "Save",
        close: "Close",
        error: "An error occurred. Please try again or check your internet connection.",
        offline: "Offline mode: Please connect to the internet.",
        edit: "Edit",
        copy: "Copy",
        preview: "Preview",
        speak: "Play Audio"
      }
    };

    let currentLanguage = localStorage.getItem('radbot-language') || 'fa';

    function initCanvasBg() {
      const canvas = document.getElementById('canvasBg');
      if (!canvas) {
        console.error('Canvas element not found');
        return;
      }
      const ctx = canvas.getContext('2d');
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      const particles = [];
      for (let i = 0; i < 100; i++) {
        particles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          vx: (Math.random() - 0.5) * 2,
          vy: (Math.random() - 0.5) * 2,
          radius: Math.random() * 2 + 1
        });
      }

      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
        particles.forEach(p => {
          p.x += p.vx;
          p.y += p.vy;
          if (p.x < 0 || p.x > canvas.width) p.vx *= -1;
          if (p.y < 0 || p.y > canvas.height) p.vy *= -1;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
          ctx.fill();
        });
        requestAnimationFrame(animate);
      }
      animate();
    }

    async function initOfflineModel() {
      if (isMobile) {
        console.log('Offline model disabled on mobile devices');
        appendMessage("bot", `<div class="error-message">ŸÖÿØŸÑ ÿ¢ŸÅŸÑÿß€åŸÜ ÿØÿ± ÿØÿ≥ÿ™⁄ØÿßŸá‚ÄåŸáÿß€å ŸÖŸàÿ®ÿß€åŸÑ ÿ∫€åÿ±ŸÅÿπÿßŸÑ ÿßÿ≥ÿ™. ŸÑÿ∑ŸÅÿßŸã ÿ®Ÿá ÿß€åŸÜÿ™ÿ±ŸÜÿ™ ŸÖÿ™ÿµŸÑ ÿ¥Ÿà€åÿØ.</div>`, true);
        return;
      }
      try {
        const { pipeline } = await import('@xenova/transformers');
        offlineModel = await pipeline('text-generation', 'distilgpt2');
        console.log('Offline model loaded');
        appendMessage("bot", "ŸÖÿØŸÑ ÿ¢ŸÅŸÑÿß€åŸÜ ÿ®ÿß ŸÖŸàŸÅŸÇ€åÿ™ ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ÿ¥ÿØ.", true);
      } catch (err) {
        console.error('Failed to load offline model:', err);
        appendMessage("bot", `<div class="error-message">ÿÆÿ∑ÿß ÿØÿ± ÿ®ÿßÿ±⁄Øÿ∞ÿßÿ±€å ŸÖÿØŸÑ ÿ¢ŸÅŸÑÿß€åŸÜ: ${err.message}</div>`, true);
      }
    }

    function setInputState(enabled) {
      const input = document.getElementById("input");
      const sendBtn = document.getElementById("sendBtn");
      if (input && sendBtn) {
        input.disabled = !enabled;
        sendBtn.disabled = !enabled;
      } else {
        console.error('Input or send button not found');
      }
    }

    function speakText(text) {
      if (!speechEnabled) return;
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.lang = 'fa-IR';
      utterance.rate = 1.0;
      utterance.pitch = 1.0;
      utterance.volume = 1.0;
      window.speechSynthesis.speak(utterance);
    }

    async function appendMessage(role, text, instant = isMobile, timestamp = new Date().toLocaleString('fa-IR', { hour: '2-digit', minute: '2-digit' }), index = null) {
      const chat = document.getElementById("chat");
      if (!chat) {
        console.error('Chat element not found');
        appendMessage("bot", `<div class="error-message">ÿÆÿ∑ÿß€å ÿ±ŸÜÿØÿ±: ÿßŸÑŸÖÿßŸÜ ⁄Üÿ™ €åÿßŸÅÿ™ ŸÜÿ¥ÿØ.</div>`, true);
        return;
      }

      const msg = document.createElement("div");
      msg.className = `msg ${role} animate__animated animate__fadeIn`;
      msg.dataset.index = index !== null ? index : getCurrentConversation().messages.length;
      msg.innerHTML = `<span class="timestamp">${timestamp}</span>${role === "user" ? "üßë: " : "ü§ñ: "}`;
      
      const actions = document.createElement("div");
      actions.className = "msg-actions";
      const copyBtn = document.createElement("button");
      copyBtn.textContent = translations[currentLanguage].copy;
      copyBtn.onclick = () => {
        navigator.clipboard.writeText(text).then(() => {
          copyBtn.textContent = "‚úÖ";
          setTimeout(() => copyBtn.textContent = translations[currentLanguage].copy, 2000);
        }).catch(err => console.error('Copy failed:', err));
      };
      actions.appendChild(copyBtn);

      if (role === "bot") {
        const speakBtn = document.createElement("button");
        speakBtn.textContent = translations[currentLanguage].speak;
        speakBtn.onclick = () => speakText(text);
        actions.appendChild(speakBtn);
      }

      if (role === "user") {
        const editBtn = document.createElement("button");
        editBtn.textContent = translations[currentLanguage].edit;
        editBtn.onclick = () => openEditModal(text, msg.dataset.index);
        actions.appendChild(editBtn);
      }

      msg.appendChild(actions);
      chat.appendChild(msg);

      const blocks = splitByCodeBlocks(text);
      isTyping = !instant;
      if (role === "bot") {
        const stopBtn = document.getElementById("stopBtn");
        if (stopBtn) stopBtn.style.display = isTyping ? "block" : "none";
      }

      for (const block of blocks) {
        if (block.type === "text") {
          const markdownDiv = document.createElement("div");
          markdownDiv.className = "markdown-body";
          if (instant || !isTyping) {
            markdownDiv.innerHTML = marked.parse(block.content);
            msg.appendChild(markdownDiv);
          } else {
            const text = block.content;
            for (let i = 0; i < text.length && isTyping; i++) {
              markdownDiv.innerHTML = marked.parse(text.slice(0, i + 1));
              msg.appendChild(markdownDiv);
              await delay(15);
              if (chat) chat.scrollTop = chat.scrollHeight;
            }
            if (isTyping) {
              markdownDiv.innerHTML = marked.parse(block.content);
            }
          }
        } else if (block.type === "code") {
          const pre = document.createElement("pre");
          pre.className = "code-block";
          pre.textContent = block.content;
          const buttonContainer = document.createElement("div");
          buttonContainer.className = "code-block-buttons";
          
          const copyBtn = document.createElement("button");
          copyBtn.className = "copy-btn";
          copyBtn.textContent = "üìã ⁄©Ÿæ€å";
          copyBtn.onclick = () => {
            navigator.clipboard.writeText(block.content).then(() => {
              copyBtn.textContent = "‚úÖ ⁄©Ÿæ€å ÿ¥ÿØ!";
              setTimeout(() => copyBtn.textContent = "üìã ⁄©Ÿæ€å", 2000);
            }).catch(err => console.error('Copy failed:', err));
          };
          buttonContainer.appendChild(copyBtn);

          if (block.language === "html") {
            const previewBtn = document.createElement("button");
            previewBtn.className = "preview-btn";
            previewBtn.textContent = translations[currentLanguage].preview;
            previewBtn.onclick = () => openPreviewModal(block.content);
            buttonContainer.appendChild(previewBtn);
          }

          pre.appendChild(buttonContainer);
          chat.appendChild(pre);
          await delay(300);
        }
      }

      if (chat) chat.scrollTop = chat.scrollHeight;
      if (role === "bot") {
        setInputState(true);
        isTyping = false;
        const stopBtn = document.getElementById("stopBtn");
        if (stopBtn) stopBtn.style.display = "none";
        if (speechEnabled) {
          speakText(text);
        }
      }
    }

    function splitByCodeBlocks(text) {
      const regex = /```(\w+)?\n([\s\S]*?)```/g;
      let result, lastIndex = 0, parts = [];
      while ((result = regex.exec(text)) !== null) {
        if (result.index > lastIndex) {
          parts.push({ type: "text", content: text.slice(lastIndex, result.index) });
        }
        parts.push({ type: "code", content: result[2], language: result[1] || "text" });
        lastIndex = regex.lastIndex;
      }
      if (lastIndex < text.length) {
        parts.push({ type: "text", content: text.slice(lastIndex) });
      }
      return parts;
    }

    function delay(ms) {
      return new Promise(r => setTimeout(r, ms));
    }

    function stopTyping() {
      isTyping = false;
      const stopBtn = document.getElementById("stopBtn");
      if (stopBtn) stopBtn.style.display = "none";
      setInputState(true);
      const typingIndicator = document.getElementById("typingIndicator");
      if (typingIndicator) typingIndicator.style.display = "none";
      window.speechSynthesis.cancel();
    }

    function openPreviewModal(htmlContent) {
      const previewModal = document.getElementById("previewModal");
      const previewIframe = document.getElementById("previewIframe");
      const overlay = document.getElementById("overlay");
      if (previewModal && previewIframe && overlay) {
        previewIframe.srcdoc = htmlContent;
        previewModal.style.display = "block";
        overlay.style.display = "block";
      } else {
        console.error('Preview modal elements not found');
      }
    }

    function closePreviewModal() {
      const previewModal = document.getElementById("previewModal");
      const previewIframe = document.getElementById("previewIframe");
      const overlay = document.getElementById("overlay");
      if (previewModal && previewIframe && overlay) {
        previewModal.style.display = "none";
        overlay.style.display = "none";
        previewIframe.srcdoc = "";
      } else {
        console.error('Preview modal elements not found');
      }
    }

    function encryptData(data) {
      return CryptoJS.AES.encrypt(JSON.stringify(data), ENCRYPTION_KEY).toString();
    }

    function decryptData(data) {
      try {
        const bytes = CryptoJS.AES.decrypt(data, ENCRYPTION_KEY);
        return JSON.parse(bytes.toString(CryptoJS.enc.Utf8));
      } catch (err) {
        console.error('Decryption failed:', err);
        return null;
      }
    }

    function saveHistory() {
      const compressed = LZString.compressToUTF16(JSON.stringify(conversations));
      localStorage.setItem("radbot-conversations", encryptData(compressed));
      if (document.getElementById("cloudSync")?.checked) {
        syncToCloud();
      }
    }

    function loadHistory() {
      const encrypted = localStorage.getItem("radbot-conversations");
      if (encrypted) {
        const decrypted = decryptData(encrypted);
        if (decrypted) {
          conversations = JSON.parse(LZString.decompressFromUTF16(decrypted));
          currentConversationId = conversations[0]?.id || Date.now();
          updateSidebar();
        } else {
          console.error('Failed to decrypt history');
        }
      }
    }

    async function syncToCloud() {
      try {
        await fetch(CLOUD_API, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ conversations: encryptData(conversations) })
        });
      } catch (err) {
        console.error('Cloud sync failed:', err);
      }
    }

    function getCurrentConversation() {
      return conversations.find(conv => conv.id === currentConversationId) || conversations[0];
    }

    function updateSidebar(searchQuery = '') {
      const historyDiv = document.getElementById("historyContent");
      if (!historyDiv) {
        console.error('History content element not found');
        return;
      }
      historyDiv.innerHTML = '';
      conversations.forEach(conv => {
        const userMessages = conv.messages.filter(msg => msg.role === 'user' && (!searchQuery || msg.content.includes(searchQuery)));
        if (userMessages.length) {
          const el = document.createElement("div");
          el.className = `history-msg ${conv.id === currentConversationId ? 'active' : ''}`;
          el.innerHTML = `${userMessages[0].content.slice(0, 40)}... <span class="timestamp">${userMessages[0].timestamp || 'ŸÜÿßŸÖÿ¥ÿÆÿµ'}</span>`;
          el.onclick = () => {
            currentConversationId = conv.id;
            showConversation(conv.id);
            updateSidebar(searchQuery);
          };
          historyDiv.appendChild(el);
        }
      });
    }

    function showConversation(convId) {
      const chat = document.getElementById("chat");
      if (!chat) {
        console.error('Chat element not found');
        return;
      }
      chat.innerHTML = '';
      const conv = conversations.find(c => c.id === convId);
      if (conv) {
        const messages = conv.messages.slice(-50);
        messages.forEach((msg, index) => {
          appendMessage(msg.role, msg.content, true, msg.timestamp, index);
        });
      }
    }

    function newConversation() {
      const newConv = { id: Date.now(), messages: [] };
      conversations.unshift(newConv);
      currentConversationId = newConv.id;
      const chat = document.getElementById("chat");
      if (chat) chat.innerHTML = '';
      updateSidebar();
      limitHistory();
    }

    function clearHistory() {
      if (confirm(translations[currentLanguage].clearHistory + "ÿü")) {
        conversations = [{ id: Date.now(), messages: [] }];
        currentConversationId = conversations[0].id;
        const chat = document.getElementById("chat");
        if (chat) chat.innerHTML = '';
        updateSidebar();
        saveHistory();
      }
    }

    function shareConversation() {
      const conv = getCurrentConversation();
      const shareData = {
        title: 'RadBot Conversation',
        text: conv.messages.map(m => `${m.role}: ${m.content}`).join('\n'),
        url: window.location.href
      };
      if (navigator.share) {
        navigator.share(shareData).catch(err => console.error('Share failed:', err));
      } else {
        navigator.clipboard.writeText(shareData.text).then(() => {
          alert('ŸÖ⁄©ÿßŸÑŸÖŸá ÿØÿ± ⁄©ŸÑ€åŸæ‚Äåÿ®Ÿàÿ±ÿØ ⁄©Ÿæ€å ÿ¥ÿØ!');
        }).catch(err => console.error('Copy failed:', err));
      }
    }

    function limitHistory() {
      if (conversations.length > 50) {
        conversations = conversations.slice(0, 50);
      }
      conversations.forEach(conv => {
        if (conv.messages.length > 100) {
          conv.messages = conv.messages.slice(-100);
        }
      });
    }

    function openEditModal(text, index) {
      const editModal = document.getElementById("editModal");
      const editInput = document.getElementById("editInput");
      const overlay = document.getElementById("overlay");
      if (editModal && editInput && overlay) {
        editingMessageIndex = parseInt(index);
        editInput.value = text;
        editModal.style.display = "block";
        overlay.style.display = "block";
      } else {
        console.error('Edit modal elements not found');
      }
    }

    function closeEditModal() {
      const editModal = document.getElementById("editModal");
      const overlay = document.getElementById("overlay");
      if (editModal && overlay) {
        editingMessageIndex = null;
        editModal.style.display = "none";
        overlay.style.display = "none";
      } else {
        console.error('Edit modal elements not found');
      }
    }

    function saveEditedMessage() {
      if (editingMessageIndex === null) return;
      const editInput = document.getElementById("editInput");
      if (!editInput) {
        console.error('Edit input element not found');
        return;
      }
      const newText = editInput.value.trim();
      if (!newText) return;

      const conv = getCurrentConversation();
      conv.messages[editingMessageIndex].content = newText;
      conv.messages[editingMessageIndex].timestamp = new Date().toLocaleString('fa-IR', { hour: '2-digit', minute: '2-digit' });
      showConversation(currentConversationId);
      saveHistory();
      closeEditModal();
    }

    async function sendToGPT(message) {
      const loading = document.getElementById("loading");
      const typingIndicator = document.getElementById("typingIndicator");
      if (loading) loading.style.display = 'block';
      if (typingIndicator) typingIndicator.style.display = 'block';
      setInputState(false);
      const conv = getCurrentConversation();
      conv.messages.push({ role: "user", content: message, timestamp: new Date().toLocaleString('fa-IR') });

      if (message.trim() === "ÿ™Ÿàÿ≥ÿ∑ ⁄ÜŸá ⁄©ÿ≥€å ÿ≥ÿßÿÆÿ™Ÿá ÿ¥ÿØ€å") {
        const reply = "ŸÖŸÜ ÿ™Ÿàÿ≥ÿ∑ ÿ±ÿßÿØŸÖŸáÿ± ŸÖÿ≠ŸÖÿØ€å ÿ®Ÿá ÿ¥ŸÖÿßÿ±Ÿá ÿ™ŸÑŸÅŸÜ 09173067537 ÿ≥ÿßÿÆÿ™Ÿá ÿ¥ÿØŸÖ üòé";
        conv.messages.push({ role: "assistant", content: reply, timestamp: new Date().toLocaleString('fa-IR') });
        await appendMessage("bot", reply);
        updateDocument();
        if (loading) loading.style.display = 'none';
        if (typingIndicator) typingIndicator.style.display = 'none';
        return;
      }

      try {
        const cacheKey = `${currentConversationId}:${message}`;
        if (responseCache.has(cacheKey)) {
          const reply = responseCache.get(cacheKey);
          conv.messages.push({ role: "assistant", content: reply, timestamp: new Date().toLocaleString('fa-IR') });
          await appendMessage("bot", reply);
          updateDocument();
          return;
        }

        if (!navigator.onLine) {
          throw new Error(translations[currentLanguage].offline);
        }

        const body = {
          model: "gpt-4o",
          messages: conv.messages.map(({ role, content }) => ({ role, content }))
        };

        const res = await fetch(API_URL, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": `Bearer ${API_KEY}`
          },
          body: JSON.stringify(body)
        });

        if (!res.ok) {
          const errorText = await res.text();
          throw new Error(`ÿÆÿ∑ÿß€å API: ${res.status} - ${errorText || "ÿßÿπÿ™ÿ®ÿßÿ± ÿ¥ŸÖÿß ÿ™ŸÖÿßŸÖ ÿ¥ÿØ. ŸÑÿ∑ŸÅÿßŸã ÿßÿπÿ™ÿ®ÿßÿ± ÿÆŸàÿØ ÿ±ÿß ÿ¥ÿßÿ±⁄ò ⁄©ŸÜ€åÿØ €åÿß ÿßÿ™ÿµÿßŸÑ ÿß€åŸÜÿ™ÿ±ŸÜÿ™ ÿ±ÿß ÿ®ÿ±ÿ±ÿ≥€å ⁄©ŸÜ€åÿØ."}`);
        }

        const data = await res.json();
        if (!data.choices || !data.choices[0] || !data.choices[0].message || !data.choices[0].message.content) {
          throw new Error("Ÿæÿßÿ≥ÿÆ API ŸÜÿßŸÖÿπÿ™ÿ®ÿ± ÿßÿ≥ÿ™.");
        }

        const reply = data.choices[0].message.content;
        responseCache.set(cacheKey, reply);
        conv.messages.push({ role: "assistant", content: reply, timestamp: new Date().toLocaleString('fa-IR') });
        await appendMessage("bot", reply);
        updateDocument();
      } catch (err) {
        console.error('API error:', err);
        appendMessage("bot", `<div class="error-message">${translations[currentLanguage].error}: ${err.message}</div>`);
      } finally {
        if (loading) loading.style.display = 'none';
        if (typingIndicator) typingIndicator.style.display = 'none';
        if (!isTyping) {
          const stopBtn = document.getElementById("stopBtn");
          if (stopBtn) stopBtn.style.display = "none";
        }
      }
    }

    function updateDocument() {
      updateSidebar();
      showSuggestions();
      limitHistory();
      saveHistory();
    }

    function sendMessage() {
      const input = document.getElementById("input");
      if (!input) {
        console.error('Input element not found');
        return;
      }
      const message = input.value.trim();
      if (!message) return;
      appendMessage("user", message);
      input.value = '';
      sendToGPT(message);
    }

    function showSuggestions() {
      const suggestionsDiv = document.getElementById("suggestions");
      if (!suggestionsDiv) {
        console.error('Suggestions element not found');
        return;
      }
      suggestionsDiv.innerHTML = '';
      const conv = getCurrentConversation();
      const lastMessage = conv.messages?.slice(-1)[0]?.content || '';
      const suggestions = [
        "ÿ™Ÿàÿ≥ÿ∑ ⁄ÜŸá ⁄©ÿ≥€å ÿ≥ÿßÿÆÿ™Ÿá ÿ¥ÿØ€å",
        "ŸÑÿ∑ŸÅÿßŸã ÿ®€åÿ¥ÿ™ÿ± ÿ™Ÿàÿ∂€åÿ≠ ÿ®ÿØŸá.",
        "ÿß€åŸÜ ÿ±Ÿà ÿ®Ÿá ÿ≤ÿ®ÿßŸÜ ÿ≥ÿßÿØŸá‚Äåÿ™ÿ± ÿ®⁄ØŸà.",
        "ŸÖÿ´ÿßŸÑ ÿ®ÿ≤ŸÜ.",
        "⁄ÜŸá ŸÖŸÜÿßÿ®ÿπ ÿØ€å⁄Øÿ±€å Ÿæ€åÿ¥ŸÜŸáÿßÿØ ŸÖ€å‚Äå⁄©ŸÜ€åÿü"
      ].filter(s => !lastMessage.includes(s));
      suggestions.forEach(s => {
        const btn = document.createElement("div");
        btn.className = "suggestion";
        btn.textContent = s;
        btn.onclick = () => {
          const input = document.getElementById("input");
          if (input) {
            input.value = s;
            sendMessage();
          }
        };
        suggestionsDiv.appendChild(btn);
      });
    }

    function applyTheme(theme, accentColor = null, bgColor = null) {
      document.body.classList.remove("light-theme", "custom-theme");
      const themeToggle = document.getElementById("themeToggle");
      if (!themeToggle) {
        console.error('Theme toggle button not found');
        return;
      }
      if (theme === 'light') {
        document.body.classList.add("light-theme");
        themeToggle.innerHTML = '<i class="fas fa-moon"></i>';
      } else if (theme === 'custom' && accentColor && bgColor) {
        document.body.classList.add("custom-theme");
        document.documentElement.style.setProperty('--accent-color', accentColor);
        document.documentElement.style.setProperty('--bg-color', bgColor);
        themeToggle.innerHTML = '<i class="fas fa-paint-brush"></i>';
      } else {
        themeToggle.innerHTML = '<i class="fas fa-sun"></i>';
      }
      localStorage.setItem("radbot-theme", theme);
      if (accentColor) localStorage.setItem("radbot-accent", accentColor);
      if (bgColor) localStorage.setItem("radbot-bg", bgColor);
    }

    function updateLanguage(lang) {
      currentLanguage = lang;
      localStorage.setItem('radbot-language', lang);
      const input = document.getElementById("input");
      const historySidebar = document.getElementById("historySidebar");
      const historySearch = document.getElementById("historySearch");
      const loading = document.getElementById("loading");
      const typingIndicator = document.getElementById("typingIndicator");
      const conversationControls = document.querySelector(".conversation-controls");
      const settingsModal = document.getElementById("settingsModal");
      const editModal = document.getElementById("editModal");
      const previewModal = document.getElementById("previewModal");

      if (input) input.placeholder = translations[currentLanguage].placeholder;
      if (historySidebar) historySidebar.querySelector("h3").textContent = `üóÇ ${translations[currentLanguage].history}`;
      if (historySearch) historySearch.placeholder = translations[currentLanguage].searchPlaceholder;
      if (loading) loading.innerHTML = `${translations[currentLanguage].processing}<span class="typing">...</span>`;
      if (typingIndicator) typingIndicator.innerHTML = `${translations[currentLanguage].typing}<span class="typing">...</span>`;
      if (conversationControls) {
        conversationControls.querySelector("button:first-child").innerHTML = `<i class="fas fa-plus"></i> ${translations[currentLanguage].newConversation}`;
        conversationControls.querySelector("button:nth-child(2)").innerHTML = `<i class="fas fa-trash"></i> ${translations[currentLanguage].clearHistory}`;
        conversationControls.querySelector("button:last-child").innerHTML = `<i class="fas fa-share"></i> ${translations[currentLanguage].share}`;
      }
      if (settingsModal) {
        settingsModal.querySelector("h3").textContent = translations[currentLanguage].settings;
        settingsModal.querySelectorAll("label")[0].textContent = translations[currentLanguage].theme;
        settingsModal.querySelectorAll("label")[1].textContent = translations[currentLanguage].customAccent;
        settingsModal.querySelectorAll("label")[2].textContent = translations[currentLanguage].customBg;
        settingsModal.querySelectorAll("label")[3].textContent = translations[currentLanguage].language;
        settingsModal.querySelectorAll("label")[4].textContent = translations[currentLanguage].cloudSync;
        settingsModal.querySelectorAll("label")[5].textContent = translations[currentLanguage].speechEnabled;
        settingsModal.querySelectorAll("button")[0].textContent = translations[currentLanguage].save;
        settingsModal.querySelectorAll("button")[1].textContent = translations[currentLanguage].close;
      }
      if (editModal) {
        editModal.querySelector("h3").textContent = translations[currentLanguage].edit;
        editModal.querySelectorAll("button")[0].textContent = translations[currentLanguage].save;
        editModal.querySelectorAll("button")[1].textContent = translations[currentLanguage].close;
      }
      if (previewModal) {
        previewModal.querySelector("h3").textContent = translations[currentLanguage].preview;
        previewModal.querySelector("button").textContent = translations[currentLanguage].close;
      }
    }

    function openSettings() {
      const settingsModal = document.getElementById("settingsModal");
      const overlay = document.getElementById("overlay");
      const themeSelect = document.getElementById("themeSelect");
      const customAccent = document.getElementById("customAccent");
      const customBg = document.getElementById("customBg");
      const languageSelect = document.getElementById("languageSelect");
      const cloudSync = document.getElementById("cloudSync");
      const speechEnabledInput = document.getElementById("speechEnabled");
      if (settingsModal && overlay && themeSelect && customAccent && customBg && languageSelect && cloudSync && speechEnabledInput) {
        themeSelect.value = localStorage.getItem("radbot-theme") || "dark";
        customAccent.value = localStorage.getItem("radbot-accent") || "#00ffff";
        customBg.value = localStorage.getItem("radbot-bg") || "#121212";
        languageSelect.value = currentLanguage;
        cloudSync.checked = localStorage.getItem("radbot-cloud") === 'true';
        speechEnabledInput.checked = speechEnabled;
        settingsModal.style.display = "block";
        overlay.style.display = "block";
      } else {
        console.error('Settings modal elements not found');
      }
    }

    function closeSettings() {
      const settingsModal = document.getElementById("settingsModal");
      const overlay = document.getElementById("overlay");
      if (settingsModal && overlay) {
        settingsModal.style.display = "none";
        overlay.style.display = "none";
      } else {
        console.error('Settings modal elements not found');
      }
    }

    function saveSettings() {
      const themeSelect = document.getElementById("themeSelect");
      const customAccent = document.getElementById("customAccent");
      const customBg = document.getElementById("customBg");
      const languageSelect = document.getElementById("languageSelect");
      const cloudSync = document.getElementById("cloudSync");
      const speechEnabledInput = document.getElementById("speechEnabled");
      if (themeSelect && customAccent && customBg && languageSelect && cloudSync && speechEnabledInput) {
        const theme = themeSelect.value;
        const accentColor = customAccent.value;
        const bgColor = customBg.value;
        const language = languageSelect.value;
        const cloudSyncChecked = cloudSync.checked;
        speechEnabled = speechEnabledInput.checked;
        applyTheme(theme, accentColor, bgColor);
        updateLanguage(language);
        localStorage.setItem("radbot-cloud", cloudSyncChecked);
        localStorage.setItem("radbot-speech", speechEnabled);
        closeSettings();
      } else {
        console.error('Settings elements not found');
      }
    }

    function enhanceTouchScroll() {
      const chat = document.getElementById("chat");
      const historySidebar = document.getElementById("historySidebar");
      if (!chat || !historySidebar) {
        console.error('Chat or history sidebar element not found');
        return;
      }

      function handleTouchMove(e, element) {
        const isScrollable = element.scrollHeight > element.clientHeight;
        if (isScrollable) {
          const touch = e.touches[0];
          const scrollTop = element.scrollTop;
          const scrollHeight = element.scrollHeight;
          const clientHeight = element.clientHeight;
          const deltaY = touch.clientY - (element.lastTouchY || touch.clientY);
          element.lastTouchY = touch.clientY;

          if ((scrollTop === 0 && deltaY > 0) || (scrollTop + clientHeight >= scrollHeight && deltaY < 0)) {
            e.preventDefault();
          }
        }
      }

      chat.addEventListener("touchstart", (e) => {
        chat.lastTouchY = e.touches[0].clientY;
      });
      chat.addEventListener("touchmove", (e) => handleTouchMove(e, chat));

      historySidebar.addEventListener("touchstart", (e) => {
        historySidebar.lastTouchY = e.touches[0].clientY;
      });
      historySidebar.addEventListener("touchmove", (e) => handleTouchMove(e, historySidebar));
    }

    document.getElementById("input")?.addEventListener("keydown", function (e) {
      if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    });

    document.getElementById("historySearch")?.addEventListener("input", function () {
      updateSidebar(this.value);
    });

    document.getElementById("themeToggle")?.onclick = () => {
      const currentTheme = document.body.classList.contains("light-theme") ? 'light' : document.body.classList.contains("custom-theme") ? 'custom' : 'dark';
      applyTheme(currentTheme === 'light' ? 'dark' : 'light');
    };

    document.getElementById("overlay")?.onclick = () => {
      closeSettings();
      closeEditModal();
      closePreviewModal();
    };

    document.getElementById("fullscreenBtn")?.onclick = () => {
      document.body.classList.toggle("fullscreen");
      const fullscreenBtn = document.getElementById("fullscreenBtn");
      if (fullscreenBtn) {
        fullscreenBtn.innerHTML = document.body.classList.contains('fullscreen') ? '<i class="fas fa-compress"></i>' : '<i class="fas fa-expand"></i>';
      }
    };

    window.onload = () => {
      initCanvasBg();
      initOfflineModel();
      loadHistory();
      const savedTheme = localStorage.getItem("radbot-theme") || "dark";
      const savedAccent = localStorage.getItem("radbot-accent") || "#00ffff";
      const savedBg = localStorage.getItem("radbot-bg") || "#121212";
      applyTheme(savedTheme, savedAccent, savedBg);
      updateLanguage(currentLanguage);
      appendMessage('bot', translations[currentLanguage].welcome);
      setTimeout(() => setInputState(true), 500);
      enhanceTouchScroll();

      if ('serviceWorker' in navigator) {
        navigator.serviceWorker.register('/service-worker.js').catch(err => console.error('Service Worker failed:', err));
      }
    };

    window.addEventListener('beforeunload', (event) => {
      if (!event.persisted) {
        saveHistory();
      }
    });
  </script>
</body>
</html>
